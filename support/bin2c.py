#!/usr/bin/python3
#
# Copyright (c) 2022 Adrian Siekierka
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from collections import OrderedDict
from datetime import datetime
from pathlib import Path
import argparse
import re
import sys

def main(args):
	current_date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	far_prefix = "" if args.near else "__far "
	attribute_suffix = ""
	if args.align is not None:
		attribute_suffix = f" __attribute__((aligned({args.align})))"
	files = OrderedDict()
	for input_str in args.input:
		inp = input_str.split(":", maxsplit=2)
		if len(inp) >= 2:
			file_name = inp[1]
			file_key = inp[0]
		else:
			file_name = inp[0]
			file_key = re.sub(r"[^a-zA-Z0-9]", "_", Path(file_name).name)
		with open(file_name, "rb") as f:
			files[file_key] = bytearray(f.read())

	# generate header file
	header_name = Path(args.output).with_suffix('.h')
	if args.header is not None:
		header_name = args.header
	with open(header_name, "w") as f:
		f.write(f"// autogenerated by bin2c.py on {current_date_str}\n")
		f.write("#pragma once\n")
		f.write("#include <stdint.h>\n")
		for field_name, data in files.items():
			f.write("\n")
			f.write("#define %s_size %d\n" % (field_name, len(data)))
			f.write("extern const uint8_t %s%s[%s_size];\n" % (far_prefix, field_name, field_name))

	# generate C file
	line_step = 16
	with open(args.output, "w") as f:
		f.write(f"// autogenerated by bin2c.py on {current_date_str}\n")
		f.write("#include <stdint.h>\n")
		for field_name, data in files.items():
			f.write("\n")
			f.write("const uint8_t %s%s[] = {\n" % (far_prefix, field_name))
			for i in range(0, len(data), line_step):
				data_part = data[i:(i + line_step)]
				data_part_str = ", ".join([str(x) for x in data_part])
				if (i + line_step) < len(data):
					f.write("\t%s, // %d\n" % (data_part_str, i))
				else:
					f.write("\t%s // %d\n" % (data_part_str, i))
			f.write("}%s;\n" % attribute_suffix)

if __name__ == '__main__':
	args_parser = argparse.ArgumentParser(
		description="Convert a collection of binary files to a .c/.h pair"
	)
	args_parser.add_argument("--header", metavar="output.h", help="Output header file. If not provided, will be in the same location as the output C file.")
	args_parser.add_argument("--align", type=int, help="Force alignment in the compiler.")
	args_parser.add_argument("--near", action="store_true", help="If present, do not emit __far keyword.")
	args_parser.add_argument("output", help="Output C file.")
	args_parser.add_argument("input", nargs="+", help="Input binary files. Can be of the form 'file.bin' or 'file_bin:file.bin'.")
	args = args_parser.parse_args()
	main(args)
