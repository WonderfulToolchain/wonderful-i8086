#!/usr/bin/python3
#
# Copyright (c) 2022 Adrian Siekierka
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from collections import OrderedDict
from datetime import datetime
from pathlib import Path
import argparse
import re
import struct
import sys

OUTPUT_TYPES = [
	('int8', 'b', 1),
	('uint8', 'B', 1),
	('int16', 'h', 2),
	('uint16', 'H', 2),
	('int32', 'i', 4),
	('uint32', 'I', 4)
]
OUTPUT_TYPE_KEYS = {x[0]:x for x in OUTPUT_TYPES}

def main(args):
	current_date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	far_prefix = "" if args.near else "__far "
	attribute_suffix = ""
	if args.align is not None:
		attribute_suffix = f" __attribute__((aligned({args.align})))"
	files = OrderedDict()
	for input_str in args.input:
		inp = input_str.split(":", maxsplit=3)
		out_type = None
		if (len(inp) >= 2) and (inp[-1] in OUTPUT_TYPE_KEYS):
			out_type = OUTPUT_TYPE_KEYS[inp[-1]]
			inp = inp[:-1]
		if len(inp) >= 2:
			file_name = inp[1]
			file_key = inp[0]
		else:
			file_name = inp[0]
			file_key = re.sub(r"[^a-zA-Z0-9]", "_", Path(file_name).name)
		with open(file_name, "rb") as f:
			data = f.read()
			if out_type is not None:
				if len(data) != out_type[2]:
					raise Exception(f"invalid length for type {out_type[0]}: {len(data)} bytes != {out_type[2]} bytes")
				files[file_key] = int(struct.unpack(f'<{out_type[1]}', data)[0])
			else:
				files[file_key] = bytearray(data)

	# generate header file
	header_name = Path(args.output).with_suffix('.h')
	if args.header is not None:
		header_name = args.header
	with open(header_name, "w") as f:
		f.write(f"// autogenerated by bin2c.py on {current_date_str}\n")
		f.write("#pragma once\n")
		f.write("#include <stdint.h>\n")
		for field_name, data in files.items():
			f.write("\n")
			if isinstance(data, int):
				f.write("#define %s %d\n" % (field_name, data))
			else:
				f.write("#define %s_size %d\n" % (field_name, len(data)))
				f.write("extern const uint8_t %s%s[%s_size];\n" % (far_prefix, field_name, field_name))

	# generate C file
	line_step = 16
	with open(args.output, "w") as f:
		f.write(f"// autogenerated by bin2c.py on {current_date_str}\n")
		f.write("#include <stdint.h>\n")
		for field_name, data in files.items():
			if not isinstance(data, int):
				f.write("\n")
				f.write("const uint8_t %s%s[] = {\n" % (far_prefix, field_name))
				for i in range(0, len(data), line_step):
					data_part = data[i:(i + line_step)]
					data_part_str = ", ".join([str(x) for x in data_part])
					if (i + line_step) < len(data):
						f.write("\t%s, // %d\n" % (data_part_str, i))
					else:
						f.write("\t%s // %d\n" % (data_part_str, i))
				f.write("}%s;\n" % attribute_suffix)

if __name__ == '__main__':
	args_parser = argparse.ArgumentParser(
		description="Convert a collection of binary files to a .c/.h pair"
	)
	args_parser.add_argument("--header", metavar="output.h", help="Output header file. If not provided, will be in the same location as the output C file.")
	args_parser.add_argument("--align", type=int, help="Force alignment in the compiler.")
	args_parser.add_argument("--near", action="store_true", help="If present, do not emit __far keyword.")
	args_parser.add_argument("output", help="Output C file.")
	args_parser.add_argument("input", nargs="+", help="Input binary files. Can be of the form 'file.bin', 'file_bin:file.bin', 'file.bin:int8' or 'file_bin:file.bin:int8'.")
	args = args_parser.parse_args()
	main(args)
